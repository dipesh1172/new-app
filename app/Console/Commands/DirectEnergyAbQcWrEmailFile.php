<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

use Carbon\Carbon;
use PhpOffice\PhpSpreadsheet\IOFactory;
use PhpOffice\PhpSpreadsheet\Spreadsheet;

use App\Models\Brand;

/**
 * Creates and delivers the emailed version of the QC WR file. This is a monthly report in DXC,
 * so the default date range is set to the previous month.
 */
class DirectEnergyAbQcWrEmailFile extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'DirectEnergy:AB:QcWr:EmailFile {--mode=} {--no-delivery} {--show-sql} {--date=} {--start-date=} {--end-date=}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Creates and emails Direct Energy\'s QC WR file';

    /**
     * Report start date.
     * 
     * @var mixed
     */
    protected $startDate = null;

    /**
     * Report end date.
     * 
     * @var mixed
     */
    protected $endDate = null;

    /**
     * Report mode: 'live' or 'test'.
     * 
     * @var string
     */
    protected $mode = 'live'; // live mode by default.

    /**
     * Report file name. This will contain just the file name plus extension of the autogenerated file name.
     * 
     * @var string
     */
    protected $fileName = '';

    /**
     * Same as this->fileName, but includes the path to the file as well.
     * 
     * @var string
     */
    protected $filePath = '';

    /**
     * Directory where generated files are housed.
     * 
     * @var string 
     */
    protected $fileDir = ''; // We're using public_path function, so the value is being set in the constructor.

    /**
     * Within fileDir directory, folder where delivered files are moved to.
     * 
     * @var string
     */
    protected $deliveredFolder = 'delivered/';

    /**
     * Brand name. Used for the brand ID lookup.
     * 
     * @var string
     */
    protected $brandName = 'Direct Energy';

    /**
     * Pretty name for this automated job. Used in subject line for results email sent to client.
     * 
     * @var string
     */
    protected $jobName = 'Direct Energy - Res - DTD - Alberta - QC - WR - Email Generation'; // We're using the same job name as the version in DXC.

    /**
     * Brand ID.
     * 
     * @var string
     */
    protected $brandId = '';

    /**
     * Distribution list.
     * 
     * @var array
     */
    protected $distroList = [
        'live' => ['alex@tpv.com', 'sharon.gallardo@answernet.com', 'Hui.Lin2@directenergy.com', 'Alan.Szeto@directenergy.com', 'Nitin.Dhingra@directenergy.com', '_TPVDeployment@directenergy.com'],
        'test' => ['alex@tpv.com', 'engineering@tpv.com'],
        'error' => ['engineering@tpv.com']  // distro list for any error emails
    ];

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();

        // Set file dir
        $this->fileDir = public_path('direct_energy/qc_wr_email/');
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $this->setup();

        // Display vars
        $this->info('Start Date: ' . $this->startDate);
        $this->info('End Date:   ' . $this->endDate);
        $this->info('Mode:       ' . $this->mode);
        $this->info('File Dir:   ' . $this->fileDir);
        $this->info('File Name:  ' . $this->fileName);
        $this->info("");

        // Retrieve TPV data
        // This will be done in two phases:
        // 1 - Get all the event and related data
        // 2 - Get the script answers data. We'll need to loop this this data as we build each line for the file.

        // Event data
        $this->info('Retrieving event data...');
        $eventData = $this->getEventData();

        // If no records, email client and exit early
        if(!$eventData) {
            $this->info('0 records. Sending results email...');

            $message = 'There were no records to send for ' . $this->startDate->format('m-d-Y') . '.';
            $this->sendEmail($message, $this->distroList[$this->mode]);

            return 0;
        }
       
        $this->info(count($eventData) . ' record(s) found.');

        // Create an array with formatted report data.
        $this->info("\nFormatting report data...");
        
        $reportData = [];
        foreach($eventData as $row) {

            // Was the TPV a dual fuel?
            $isDual = $this->isDualFuel($row->rate_program_code);

            // Fuel type for specific record we're looking at
            $commodity = $row->commodity;

            // Retrieve Yes/No responses to the rate scripts
            $rateScriptAnswers = $this->getRateScriptAnswers($row->event_id, $row->rate_id, ($isDual ? $commodity : null));

            // Determine Contract Offering value
            $contractOffering = "";
            if($row->result == 'Sale') {
                $contractOffering = 'YES';
            } else {
                $contractOffering = 'NO';
            }

            // Program codes are number. Due to how we have to deal with dual fuel rates
            // and AB vs SK, our codes have e/g/sk/[ab] suffixes. Remove them.
            // At this point we're assuming that we'll only be dealing with digits, so remove all non-digit characters
            $programCode = preg_replace('/\D+/', '', $row->rate_program_code);

            // Parse custom field data
            $podId = "";
                
            $customFields = [];

            if($row->custom_fields) {
                $customFields = json_decode($row->custom_fields);
            }

            foreach($customFields AS $customField) {

                switch(strtolower($customField->output_name)) {

                    case 'pod_id':
                        $podId = $customField->value;
                        break;
                }
            }

            $rowFormatted = [
                'contract_number' => strtoupper($row->account_number1),
                'first_name' => strtoupper($row->auth_first_name),
                'last_name' => strtoupper($row->auth_last_name),
                'main_phone' => substr($row->btn, 2), // Drop the +1
                'question_1' => $rateScriptAnswers->question_1,
                'question_2' => $rateScriptAnswers->question_2,
                'question_3' => $rateScriptAnswers->question_3,
                'question_4' => $rateScriptAnswers->question_4,
                'question_5' => $rateScriptAnswers->question_5,
                'vendor_id' => $row->vendor_grp_id,
                'tpv_date' => Carbon::parse($row->interaction_created_at)->format('Y-m-d'), // Matches the format used by DXC
                'contract_offering' => $contractOffering,
                'program_code' => $programCode,
                'program' => strtoupper($row->product_name),
                'office_id' => $podId
            ];

            $reportData[] = $rowFormatted;
        }

        // Create the XLS file
        $this->info('Writing data to Xls file...');
        $this->writeXlsFile($reportData, $this->filePath);
        // TODO: Rework XLS function call to get result and handle errors

        // Deliver the file
        if(!$this->option('no-delivery')) {
            $this->info("\nEmailing report...");

            // Email message here is a copy of what we're sending in DXC.
            $message = 'File ' . $this->fileName . ' was successfully created.';
            $attachments = [$this->filePath];

            $emailResult = $this->sendEmail($message, $this->distroList[$this->mode], $attachments);

            if($emailResult->result == 'success') {
                // Move file to 'delivered' folder
                $this->info('Delivery succeeded. Moving file to delivered folder.');
                rename($this->filePath, $this->fileDir . $this->deliveredFolder . $this->fileName);

            } else {
                $message = "At least one delivery of file failed. Delivery log:\n\n" . $emailResult->message;
                $this->sendEmail($message, $this->distroList['error']);
            }
        } else {
            $this->info('--no-delivery arg is set. Skipping email delivery');
        }

        return 1;
    }

    /**
     * Checks the program code to determine if the TPV was for a dual fuel
     */
    private function isDualFuel($programCode) {

        // Convert to all lower case and trim off any spaces
        $str = trim(strtolower($programCode));

        // Dual fuel program codes end in 'e' or 'g'. Additionally, for SK, the program codes end in 'SK'
        if(str_ends_with($str, 'e') || str_ends_with($str, 'g') || str_ends_with($str, 'esk') || str_ends_with($str, 'gsk')) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Retreive Event data from DB
     */
    private function getEventData() {
        
        $query = '
            SELECT
                events.confirmation_code,
                events.id AS event_id,
                stats_product.account_number1,
                stats_product.auth_first_name,
                stats_product.auth_last_name,
                stats_product.btn,
                stats_product.vendor_grp_id,
                stats_product.interaction_created_at,
                stats_product.result,
                stats_product.rate_program_code,
                stats_product.rate_id,
                stats_product.product_name,
                stats_product.custom_fields,
                stats_product.commodity
            FROM events
            JOIN stats_product ON events.id = stats_product.event_id AND stats_product.deleted_at IS NULL
            LEFT JOIN stats_product sp2 ON events.id = sp2.event_id AND (stats_product.created_at < sp2.created_at OR (stats_product.created_at = sp2.created_at AND stats_product.id < sp2.id))
            WHERE
                sp2.id IS NULL
                AND events.deleted_at IS NULL
                AND DATE(events.created_at) >= :start_date AND DATE(events.created_at) <= :end_date
                AND events.brand_id = :brand_id
                AND stats_product.result IN (:sale, :no_sale)
                AND stats_product.service_state IN (:ab, :sk)
            ORDER BY events.created_at DESC
        ';

        $bindings = [
            'start_date' => $this->startDate,
            'end_date' => $this->endDate,
            'brand_id' => $this->brandId,
            'sale' => 'sale',
            'no_sale' => 'no sale',
            'ab' => 'AB',
            'sk' => 'SK'
        ];

        if($this->option('show-sql')) {
            $this->info('QUERY:');
            $this->info($query);
            $this->info("\nBindings:");
            print_r($bindings);
        }

        $data = DB::select(DB::raw($query), $bindings);

        return $data;
    }

    /**
     * Retreive Script Answers data from DB
     */
    private function getRateScriptAnswersData($eventId, $commodity = null) {
        
        // Do a distinct. Sometimes the rate script answer entries are duplicated.
        $query = '
            SELECT DISTINCT created_at, question_id, answer_type, answer
            FROM script_answers
            WHERE
                event_id = :event_id
                AND question_id LIKE :question_id
            ORDER BY created_at
        ';

        $bindings = [
            'event_id' => $eventId
        ];

        if($commodity) {
            $bindings['question_id'] = '%x-rate-script%' . $commodity . '%';
        } else {
            $bindings['question_id'] = '%x-rate-script%';
        }

        $data = DB::select(DB::raw($query), $bindings);

        return $data;
    }

    /**
     * Retreives a rate reocrd
     */
    private function getRateRecord($rateId) {
        
        $query = '
            SELECT id, scripting
            FROM rates
            WHERE
                id = :rate_id
            ORDER BY created_at DESC
            LIMIT 1
        ';

        $bindings = [
            'rate_id' => $rateId
        ];

        $data = DB::select(DB::raw($query), $bindings);

        return $data[0];
    }

    /**
     * Retrieves rate script Yes/No answers from the script_answers.
     */
    private function getRateScriptAnswers($eventId, $rateId, $commodity = null) {

        if($commodity) {
            if(strtolower($commodity) == 'natural gas') {
                $commodity = 'gas';
            } else {
                $commodity = strtolower($commodity);
            }
        }

        // Retrieve script answer data
        $scriptAnswers = $this->getRateScriptAnswersData($eventId, $commodity);

        // Retrieve rate data
        $rateData = $this->getRateRecord($rateId);

        // Extract rate scripts from rate data.
        // When rate scripts are filled out in the UI sequentially, they're stored as a JSON object with an array of questions.
        // However, when a gap exists (ex. Rate Script 1 and Rate Script 3 are populated, but Rate Script 2 is left blank), 
        //   the question list is stored as an object with numeric key names instead.
        // To deal with this, we'll used the associative array option when calling decode_json, so we'll treat everything as an array.
        $scripting = json_decode($rateData->scripting, true);

        // This is the object we'll fill with the script answers
        $result = [
            'question_1' => '',
            'question_2' => '',
            'question_3' => '',
            'question_4' => '',
            'question_5' => '',
        ];
        
        // Populate the questions object.
        // There is no direct tie-in between the rate script answer to the actual rate script.
        // We must infer which rate script answer goes with which rate script based on order of appearance when sorted by date.
        // TODO: Update this code to detect language. For now, we're assuming English only.
        try {            
            // The answers and script numbers will not always line up. This is because the counter on the rate script question
            // references the order of appearance in the script, not which rate script field was filled.

            // For example, if we filled out rate script 1 and rate script 3 only, we would expect
            // the question IDs would look something like this:
            // 0-1-0-0-0-x-rate-script-1-0-1
            // 0-1-0-2-0-x-rate-script-1-0-0
            // However, we'll actually see this:
            // 0-1-0-0-0-x-rate-script-1-0-1
            // 0-1-0-1-0-x-rate-script-1-0-0
            // So, we can't use the ID itself. We'll have to infer by order of appearance when sorted by date (already handled by getScriptAnswerData())

            $answerIndex = 0;
            foreach($scripting['english'] as $key => $value) {
                if(empty($value)) { // Rate script not set. Go to next item.
                    continue;
                }

                $resultKey = 'question_' . ($key + 1);

                $result[$resultKey] = strtoupper($scriptAnswers[$answerIndex]->answer);

                $answerIndex++;  // This only increments when current iteration's rate script is not empty
            }
        } catch(\Exception $e) {
            info("##### MAP ANSWERS EXCEPTION", [$e->getMessage()]);
            // TODO: Handle error. For now, we'll just continue and return an unfilled result
        }

        return (object)$result;
    }

    /**
     * Set up global vars and handle command line args
     * 
     * @return mixed
     */
    private function setup() {

        // Set the default date range
        $this->startDate = Carbon::now("America/Chicago")->addMonth(-1)->firstOfMonth();                // Get first day of previous month
        $this->endDate = Carbon::yesterday("America/Chicago")->addMonth(-1)->lastOfMonth()->endOfDay(); // Get last day of previous month

        // Check for single-date date range.
        if($this->option('date')) {
            $this->startDate = Carbon::parse($this->option('date'))->startOfDay();
            $this->endDate = Carbon::parse($this->option('date'))->endOfDay();

            $this->info('Using custom date range.');
        }

        // Check for custom date range. Only if 'date' option is not provided. Custom date range will only be used if both start and end dates are present.
        if (!$this->option('date') && $this->option('start-date') && $this->option('end-date')) {
            $this->startDate = Carbon::parse($this->option('start-date'))->startOfDay();
            $this->endDate = Carbon::parse($this->option('end-date'))->endOfDay();

            if ($this->startDate > $this->endDate) {
                $tmp = $this->startDate;
                $this->startDate = $this->endDate->startOfDay();
                $this->endDate = $tmp->endOfDay();
            }
            $this->info('Using custom date range.');
        }

        // Check for and validate mode.
        if ($this->option('mode')) {
            if (
                strtolower($this->option('mode')) == 'live' ||
                strtolower($this->option('mode')) == 'test'
            ) {
                $this->mode = strtolower($this->option('mode'));
            } else {
                $this->error('Unrecognized --mode: ' . $this->option('mode'));
                return -1;
            }
        }

        // Build the file name. We're using the date range start date for the date in the file name.
        // For the file number, we start at 1, then check if we previously generated a file with that name (in the delivered files folder).
        // If a file is found, we increment the file counter until a file with the generated name isn't found.
        $fileNum = 1;
        $this->fileName = ($this->mode == 'test' ? 'TEST_' : '') . 'QC_WR_EMAIL_' . $fileNum . '_' . $this->startDate->format('Ymd') . '.xls';

        while(file_exists($this->fileDir . $this->deliveredFolder . $this->fileName)) {
            $fileNum++;
            $this->fileName = ($this->mode == 'test' ? 'TEST_' : '') . 'QC_WR_EMAIL_' . $fileNum . '_' . $this->startDate->format('Ymd') . '.xls';
        }

        // Now that we have a good file name, set the filePath variable
        $this->filePath = $this->fileDir . $this->fileName;

        // Set the brand_id
        $brandData = Brand::where(
            'name',
            $this->brandName
        )->whereNotNull(
            'client_id'
        )->get()->first();

        if(!$brandData) {
            $this->error('Unable to locate Brand record for: ' . $this->brandName);
            $this->error('Exiting program');
            exit(-1);
        }

        $this->brandId = $brandData->id;
    }

    /**
     * Sends an email.
     *
     * @param string $message - Email body.
     * @param array  $distro  - Distribution list.
     * @param array  $files   - Optional. List of files to attach.
     *
     * @return object - Result object
     */
    private function sendEmail(string $message, array $distro, array $files = array())
    {
        $result = (object)[
            'result' => 'success',     // Starts as 'success', but changes to 'error' upon first failed delivery
            'messages' => []
        ];

        // Build email subject
        if ('production' != config('app.env')) {
            $subject = $this->jobName . ' (' . config('app.env') . ') ' . Carbon::now('America/Chicago');
        } else {
            $subject = $this->jobName . ' ' . Carbon::now('America/Chicago');
        }

        if ($this->mode == 'test') {
            $subject = '(TEST) ' . $subject;
        }

        // Data object for email template
        $data = [
            'subject' => '',
            'content' => $message
        ];

        // Send email. One email per recipient will be sent.
        // TODO: Can we do a group message, like in DXC?
        for ($i = 0; $i < count($distro); ++$i) {
            $status = 'Email to ' . $distro[$i] . ' at ' . Carbon::now('America/Chicago') . '. Status: ';

            try {
                Mail::send(
                    'emails.generic',
                    $data,
                    function ($message) use ($subject, $distro, $i, $files) {
                        $message->subject($subject);
                        $message->from('no-reply@tpvhub.com');
                        $message->to(trim($distro[$i]));

                        // Add attachments
                        foreach ($files as $file) {
                            $message->attach($file);
                        }
                    }
                );
            } catch (\Exception $e) {
                $status .= 'Error! The reason reported is: ' . $e;
                $result->result = 'error';
                $result->messages[] = $status;
            }

            $status .= 'Success!';
            $result->messages[] = $status;
        }

        return $result;
    }

    /**
     * Writes an Excel file from a data array. Data array should
     * use named keys as the keys are used for the header row.
     */
    private function writeXlsFile($data, $fileName) {

        try {
            $headers = array_keys($data[0]);

            $spreadsheet = new Spreadsheet();
            $sheet = $spreadsheet->getActiveSheet();
            $sheet->fromArray($headers, null, 'A1');
            $sheet->fromArray($data, null, 'A2');

            $writer = IOFactory::createWriter($spreadsheet, 'Xls');
            $writer->save($fileName);
        } catch (\Exception $e) {
            // TODO: Handle
        }

        // TODO: Return a result
    }
}
