<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Mail;

use Carbon\Carbon;
use League\Flysystem\Filesystem;
use League\Flysystem\Adapter\Ftp;
use League\Flysystem\Sftp\SftpAdapter;

use App\Models\Brand;
use App\Models\ProviderIntegration;

/**
 * Creates and delivers the emailed version of the QC WR file. This is a monthly report in DXC,
 * so the default date range is set to the previous month.
 */
class DirectEnergyAbQcWrFtpFile extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'DirectEnergy:AB:QcWr:FtpFile {--mode=} {--no-delivery} {--show-sql} {--date=} {--start-date=} {--end-date=}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Creates and FTPs Direct Energy\'s QC WR file';

    /**
     * Report start date.
     * 
     * @var mixed
     */
    protected $startDate = null;

    /**
     * Report end date.
     * 
     * @var mixed
     */
    protected $endDate = null;

    /**
     * Report mode: 'live' or 'test'.
     * 
     * @var string
     */
    protected $mode = 'live'; // live mode by default.

    /**
     * Report file name. This will contain just the file name plus extension of the autogenerated file name.
     * 
     * @var string
     */
    protected $fileName = '';

    /**
     * Same as this->fileName, but includes the path to the file as well.
     * 
     * @var string
     */
    protected $filePath = '';

    /**
     * Directory where generated files are housed.
     * 
     * @var string 
     */
    protected $fileDir = ''; // We're using public_path function, so the value is being set in the constructor.

    /**
     * Within fileDir directory, folder where delivered files are moved to.
     * 
     * @var string
     */
    protected $deliveredFolder = 'delivered/';

    /**
     * Brand name. Used for the brand ID lookup.
     * 
     * @var string
     */
    protected $brandName = 'Direct Energy';

    /**
     * Pretty name for this automated job. Used in subject line for results email sent to client.
     * 
     * @var string
     */
    protected $jobName = 'Direct Energy - Res - DTD - Alberta - QC - WR - FTP File Generation'; // We're using the same job name as the version in DXC.

    /**
     * Brand ID.
     * 
     * @var string
     */
    protected $brandId = '';

    /**
     * Distribution list.
     * 
     * @var array
     */
    protected $distroList = [
        'live' => ['alex@tpv.com', 'sharon.gallardo@answernet.com','curt.cadwell@answernet.com','_tpvteam@directenergy.com', 'Contract.alberta@directenergy.com','dxc_autoemails@tpv.com'],
        'test' => ['alex@tpv.com', 'curt.cadwell@answernet.com','curt@tpv.com','engineering@tpv.com'],
        //'test' => ['curt.cadwell@answernet.com','curt@tpv.com','engineering@tpv.com'],
        'error' => ['engineering@tpv.com']  // distro list for any error emails
    ];

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();

        // Set file dir
        $this->fileDir = public_path('direct_energy/qc_wr_ftp/');
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $this->setup();

        // Display vars
        $this->info('Start Date: ' . $this->startDate);
        $this->info('End Date:   ' . $this->endDate);
        $this->info('Mode:       ' . $this->mode);
        $this->info('File Dir:   ' . $this->fileDir);
        $this->info('File Name:  ' . $this->fileName);
        $this->info("");

        // Retrieve TPV data
        // This will be done in two phases:
        // 1 - Get all the event and related data
        // 2 - Get the script answers data. We'll need to loop this this data as we build each line for the file.

        // Event data
        $this->info('Retrieving event data...');
        $eventData = $this->getEventData();

        // If no records, email client and exit early
        if(!$eventData) {
            $this->info('0 records. Sending results email...');

            $message = 'There were no records to send for ' . $this->startDate->format('m-d-Y') . '.';
            $this->sendEmail($message, $this->distroList[$this->mode]);

            return 0;
        }
       
        $this->info(count($eventData) . ' record(s) found.');

        // Create an array with formatted report data.
        $this->info("\nFormatting report data...");
        
        $reportData = [];

        $progressBar = $this->output->createProgressBar(count($eventData));
        $progressBar->start();
        
        foreach($eventData as $row) {

            // Was the TPV a dual fuel?
            $isDual = $this->isDualFuel($row->rate_program_code);

            // Fuel type for specific record we're looking at
            $commodity = $row->commodity;

            // Retrieve Yes/No responses to the rate scripts
            $rateScriptAnswers = $this->getRateScriptAnswers($row->event_id, $row->rate_id, ($isDual ? $commodity : null));

            // Determine Contract Offering value
            $contractOffering = "";
            if($row->result == 'Sale') {
                $contractOffering = 'YES';
            } else {
                $contractOffering = 'NO';
            }

            // Program codes are number. Due to how we have to deal with dual fuel rates
            // and AB vs SK, our codes have e/g/sk/[ab] suffixes. Remove them.
            // At this point we're assuming that we'll only be dealing with digits, so remove all non-digit characters
            $programCode = preg_replace('/\D+/', '', $row->rate_program_code);

            $rowFormatted = [
                'contract_number' => strtoupper($row->account_number1),
                'first_name' => strtoupper($row->auth_first_name),
                'last_name' => strtoupper($row->auth_last_name),
                'main_phone' => substr($row->btn, 2), // Drop the +1
                'question_1' => $rateScriptAnswers->question_1,
                'question_2' => $rateScriptAnswers->question_2,
                'question_3' => $rateScriptAnswers->question_3,
                'question_4' => $rateScriptAnswers->question_4,
                'question_5' => $rateScriptAnswers->question_5,
                'placeholder1' => '',
                'placeholder2' => '',
                'placeholder3' => '',
                'placeholder4' => '',
                'vendor_id' => $row->sales_agent_rep_id,
                'tpv_date' => Carbon::parse($row->interaction_created_at)->format('Y-m-d'), // Matches the format used by DXC
                'contract_offering' => $contractOffering,
                'program_code' => $programCode,
                'program' => strtoupper($row->product_name),
                'offer_code' => $row->rate_external_id,
                'promo_exists' => ($row->promotion_code ? 'Yes' : ''),
                'placeholder4' => '',
                'placeholder5' => ''
            ];

            $reportData[] = $rowFormatted;

            $progressBar->advance();
        }

        $progressBar->finish();

        // Create the CSV file
        $this->info('Writing data to CSV file...');
        $this->writeCsvFile($reportData, $this->filePath);

        // Start PGP Encrypt
        $gpg = gnupg_init();
        // this displays all keys in keyring pass a blank string to list keys in php  
        // use gpg --list-keys in terminal to mess with keyring lots of options
        // https://www.gnupg.org/documentation/manpage.html
        // https://stackoverflow.com/questions/15969740/encrypt-files-using-pgp-in-php
        $errKey = gnupg_addencryptkey($gpg,'1B98B1F9A3C66946AEB1A5F1031251540784824D');  // get this fingerprint from ringkey use gpg command
        if ($errKey) {
            $uploadFileContent = file_get_contents($this->filePath);
            $encryptFile = gnupg_encrypt($gpg,$uploadFileContent);
            $error1 = file_put_contents($this->filePath . '.pgp', $encryptFile);
        } else {
            $this->info('Encryption failed.');
            $this->sendEmail('Error with Encryption ' . $this->filePath,$this->distroList['error']);
            return -1; // Quit early. 
        }

        // END PGP Encrypt

        // Deliver the file
        if(!$this->option('no-delivery')) {
            $this->filePath = $this->filePath . '.pgp'; // add additional suffix for encrypted file pgp
            $this->info('Delivering the file...');
            
            $ftpResult = $this->ftpFile();

            $this->info("FTP Result:");
            print_r($ftpResult);

            // On success, send client a notification email
            if($ftpResult->result == 'success') {
                $this->info("\nFile delivered. Sending email notification...");

                // Email message here is a copy of what we're sending in DXC.
                $message = 'File ' . $this->fileName . ' was successfully uploaded.';

                $emailResult = $this->sendEmail($message, $this->distroList[$this->mode]);

                if($emailResult->result == 'success') {

                    // Move file to 'delivered' folder
                    $this->info('Notification email succeeded. Moving file to delivered folder.');
                    rename($this->filePath, $this->fileDir . $this->deliveredFolder . $this->fileName);

                } else {                    
                    $message = "At least one email delivery of the notification failed. Delivery log:\n\n" . $emailResult->message;
                    $this->sendEmail($message, $this->distroList['error']);
                }
            } else {
                $this->info("Failed to FTP file. Sending alert email...");
                $this->sendEmail(
                        'Failed to FTP file ' . $this->filePath
                        . "\n\nMessage: " . $ftpResult->message, 
                        $this->distroList['error']
                );
            }
        } else {
            $this->info('--no-delivery arg is set. Skipping FTP delivery');
        }

        return 1;
    }

    /**
     * Delivers file to client via FTP
     */
    private function ftpFile() {

        $ftpSettings = $this->getFtpConfig();
        if(!$ftpSettings) {
            return (object)[
                'result' => 'error',
                'message' => 'Unable to find FTP settings in provider_integrations table'
            ];
        }

        // Make sure file exists
        if(!file_exists($this->filePath)) {
            return (object)[
                'result' => 'error',
                'message' => 'Unable to locate file; ' . $this->filePath
            ];
        }

        try {

            // DXC site uses FTP, client site uses SSH/SFTP
            $adapter = null;
            if($this->mode == 'live') {
                $adapter = new SftpAdapter($ftpSettings);
            } else {
                $adapter = new Ftp($ftpSettings);
            }

            $fs = new Filesystem($adapter);
            $stream = fopen($this->filePath, 'r+');

            $fs->writeStream(
                $this->fileName . '.pgp',
                $stream
            );

            $this->info("TEST");
            if(is_resource($stream)) {
                fclose($stream);
            }

        } catch(\Exception $e) {
            return (object)[
                'result' => 'error',
                'message' => 'Exception occurred: ' . $e->getMessage()
            ];
        }

        return (object)[
            'result' => 'success',
            'message' => ''
        ];
    }

    /**
     * Retrieve FTP config from provider_integrations table and
     * build our FTP config from that data.
     */
    private function getFtpConfig() {
        
        // Get data from DB
        if($this->mode == 'live') {
            $pi = ProviderIntegration::where( // Get client's FTP settings
                'brand_id',
                $this->brandId
            )->where(
                'provider_integration_type_id',
                1
            )->where(
                'service_type_id',
                32
            )->first();
        } else {
            $pi = ProviderIntegration::where( // For test mode, get our own FTP settigns
                'provider_integration_type_id',
                3 // FTP
            )->where(
                'service_type_id',
                35 // DXC Test FTP Site
            )->first();
        }

        // Can't find record, return false.
        if (empty($pi)) {
            return null;
        }

        $settings = [
            'host' => $pi->hostname,
            'username' => $pi->username,
            'password' => $pi->password,
            'port' => ($this->mode == 'test' ? 21 : 22),
            'root' => '/',
            'passive' => true,
            'timeout' => 30
        ];
    

        $this->info("FTP Settings:");
        print_r($settings);

        return $settings;
    }

    /**
     * Checks the program code to determine if the TPV was for a dual fuel
     */
    private function isDualFuel($programCode) {

        // Convert to all lower case and trim off any spaces
        $str = trim(strtolower($programCode));

        // Dual fuel program codes end in 'e' or 'g'. Additionally, for SK, the program codes end in 'SK'
        if(str_ends_with($str, 'e') || str_ends_with($str, 'g') || str_ends_with($str, 'esk') || str_ends_with($str, 'gsk')) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Retreive Event data from DB
     */
    private function getEventData() {
        
        // Tokenized query string
        $query = '
            SELECT
                Distinct
                events.confirmation_code,
                events.id AS event_id,
                stats_product.account_number1,
                stats_product.auth_first_name,
                stats_product.auth_last_name,
                stats_product.btn,
                stats_product.vendor_grp_id,
                stats_product.interaction_created_at,
                stats_product.result,
                stats_product.rate_program_code,
                stats_product.rate_external_id,
                stats_product.rate_id,
                stats_product.product_name,
                stats_product.commodity,
                brand_promotions.promotion_code,
                stats_product.sales_agent_rep_id
            FROM events
            JOIN stats_product ON events.id = stats_product.event_id AND stats_product.deleted_at IS NULL
            LEFT JOIN stats_product sp2 ON events.id = sp2.event_id AND (stats_product.created_at < sp2.created_at OR (stats_product.created_at = sp2.created_at AND stats_product.id < sp2.id))
            LEFT JOIN event_product ON events.id = event_product.event_id
            LEFT JOIN brand_promotions ON event_product.brand_promotion_id = brand_promotions.id
            WHERE
                sp2.id IS NULL
                AND events.deleted_at IS NULL
                AND DATE(events.created_at) >= :start_date AND DATE(events.created_at) <= :end_date
                AND events.brand_id = :brand_id
                AND stats_product.result IN (:sale, :no_sale)
                AND stats_product.service_state IN (:ab, :sk)
            ORDER BY stats_product.confirmation_code DESC
        ';

        // Bindings for above SQL statement
        $bindings = [
            'start_date' => $this->startDate,
            'end_date' => $this->endDate,
            'brand_id' => $this->brandId,
            'sale' => 'sale',
            'no_sale' => 'no sale',
            'ab' => 'AB',
            'sk' => 'SK'
        ];

        if($this->option('show-sql')) {
            $this->info('QUERY:');
            $this->info($query);
            $this->info("\nBindings:");
            print_r($bindings);
        }

        $data = DB::select(DB::raw($query), $bindings);

        return $data;
    }

    /**
     * Retreive Script Answers data from DB
     */
    private function getRateScriptAnswersData($eventId, $commodity = null) {
        
        // Do a distinct. Sometimes the rate script answer entries are duplicated.
        $query = '
            SELECT DISTINCT created_at, question_id, answer_type, answer
            FROM script_answers
            WHERE
                event_id = :event_id
                AND question_id LIKE :question_id
            ORDER BY created_at
        ';

        $bindings = [
            'event_id' => $eventId
        ];

        if($commodity) {
            $bindings['question_id'] = '%x-rate-script%' . $commodity . '%';
        } else {
            $bindings['question_id'] = '%x-rate-script%';
        }

        $data = DB::select(DB::raw($query), $bindings);

        return $data;
    }

    /**
     * Retreives a rate reocrd
     */
    private function getRateRecord($rateId) {
        
        $query = '
            SELECT id, scripting
            FROM rates
            WHERE
                id = :rate_id
            ORDER BY created_at DESC
            LIMIT 1
        ';

        $bindings = [
            'rate_id' => $rateId
        ];

        $data = DB::select(DB::raw($query), $bindings);

        return $data[0];
    }

    /**
     * Retrieves rate script Yes/No answers from the script_answers.
     */
    private function getRateScriptAnswers($eventId, $rateId, $commodity = null) {

        if($commodity) {
            if(strtolower($commodity) == 'natural gas') {
                $commodity = 'gas';
            } else {
                $commodity = strtolower($commodity);
            }
        }

        // Retrieve script answer data
        $scriptAnswers = $this->getRateScriptAnswersData($eventId, $commodity);

        // Retrieve rate data
        $rateData = $this->getRateRecord($rateId);

        // Extract rate scripts from rate data.
        // When rate scripts are filled out in the UI sequentially, they're stored as a JSON object with an array of questions.
        // However, when a gap exists (ex. Rate Script 1 and Rate Script 3 are populated, but Rate Script 2 is left blank), 
        //   the question list is stored as an object with numeric key names instead.
        // To deal with this, we'll used the associative array option when calling decode_json, so we'll treat everything as an array.
        $scripting = json_decode($rateData->scripting, true);

        // This is the object we'll fill with the script answers
        $result = [
            'question_1' => '',
            'question_2' => '',
            'question_3' => '',
            'question_4' => '',
            'question_5' => '',
        ];
        
        // Populate the questions object.
        // There is no direct tie-in between the rate script answer to the actual rate script.
        // We must infer which rate script answer goes with which rate script based on order of appearance when sorted by date.
        // TODO: Update this code to detect language. For now, we're assuming English only.
        try {            
            // The answers and script numbers will not always line up. This is because the counter on the rate script question
            // references the order of appearance in the script, not which rate script field was filled.

            // For example, if we filled out rate script 1 and rate script 3 only, we would expect
            // the question IDs would look something like this:
            // 0-1-0-0-0-x-rate-script-1-0-1
            // 0-1-0-2-0-x-rate-script-1-0-0
            // However, we'll actually see this:
            // 0-1-0-0-0-x-rate-script-1-0-1
            // 0-1-0-1-0-x-rate-script-1-0-0
            // So, we can't use the ID itself. We'll have to infer by order of appearance when sorted by date (already handled by getScriptAnswerData())

            $answerIndex = 0;
            foreach($scripting['english'] as $key => $value) {
                if(empty($value)) { // Rate script not set. Go to next item.
                    continue;
                }

                $resultKey = 'question_' . ($key + 1);

                $result[$resultKey] = strtoupper($scriptAnswers[$answerIndex]->answer);

                $answerIndex++;  // This only increments when current iteration's rate script is not empty
            }
        } catch(\Exception $e) {
            info("##### MAP ANSWERS EXCEPTION", [$e->getMessage()]);
            // TODO: Handle error. For now, we'll just continue and return an unfilled result
        }

        return (object)$result;
    }

    /**
     * Set up global vars and handle command line args
     * 
     * @return mixed
     */
    private function setup() {

        // Set the default date range
        $this->startDate = Carbon::yesterday("America/Chicago");           // Get yesterday's date
        $this->endDate = Carbon::yesterday("America/Chicago")->endOfDay(); // Get yesterday's date with 23:59:59 as the time.

        // Check for single-date date range.
        if($this->option('date')) {
            $this->startDate = Carbon::parse($this->option('date'))->startOfDay();
            $this->endDate = Carbon::parse($this->option('date'))->endOfDay();

            $this->info('Using custom date range.');
        }

        // Check for custom date range. Only if 'date' option is not provided. Custom date range will only be used if both start and end dates are present.
        if (!$this->option('date') && $this->option('start-date') && $this->option('end-date')) {
            $this->startDate = Carbon::parse($this->option('start-date'))->startOfDay();
            $this->endDate = Carbon::parse($this->option('end-date'))->endOfDay();

            if ($this->startDate > $this->endDate) {
                $tmp = $this->startDate;
                $this->startDate = $this->endDate->startOfDay();
                $this->endDate = $tmp->endOfDay();
            }
            $this->info('Using custom date range.');
        }

        // Check for and validate mode.
        if ($this->option('mode')) {
            if (
                strtolower($this->option('mode')) == 'live' ||
                strtolower($this->option('mode')) == 'test'
            ) {
                $this->mode = strtolower($this->option('mode'));
            } else {
                $this->error('Unrecognized --mode: ' . $this->option('mode'));
                return -1;
            }
        }

        // File date/time. We'll use start date for the date part of the file name, but the current time for the time part of the filename
        $fileDate = $this->startDate->format('Ymd');
        $fileTime = Carbon::now("America/Chicago")->format('His');

        // Build the file name.
        $this->fileName = ($this->mode == 'test' ? 'TEST_' : '') . 'QC_WR_78_' . $fileDate . $fileTime . '.csv';

        $this->filePath = $this->fileDir . $this->fileName;

        // Set the brand_id
        $brandData = Brand::where(
            'name',
            $this->brandName
        )->whereNotNull(
            'client_id'
        )->get()->first();

        if(!$brandData) {
            $this->error('Unable to locate Brand record for: ' . $this->brandName);
            $this->error('Exiting program');
            exit(-1);
        }

        $this->brandId = $brandData->id;
    }

    /**
     * Sends an email.
     *
     * @param string $message - Email body.
     * @param array  $distro  - Distribution list.
     * @param array  $files   - Optional. List of files to attach.
     *
     * @return object - Result object
     */
    private function sendEmail(string $message, array $distro, array $files = array())
    {
        $result = (object)[
            'result' => 'success',     // Starts as 'success', but changes to 'error' upon first failed delivery
            'messages' => []
        ];

        // Build email subject
        if ('production' != config('app.env')) {
            $subject = $this->jobName . ' (' . config('app.env') . ') ' . Carbon::now('America/Chicago');
        } else {
            $subject = $this->jobName . ' ' . Carbon::now('America/Chicago');
        }

        if ($this->mode == 'test') {
            $subject = '(TEST) ' . $subject;
        }

        // Data object for email template
        $data = [
            'subject' => '',
            'content' => $message
        ];

        // Send email. One email per recipient will be sent.
        // TODO: Can we do a group message, like in DXC?
        for ($i = 0; $i < count($distro); ++$i) {
            $status = 'Email to ' . $distro[$i] . ' at ' . Carbon::now('America/Chicago') . '. Status: ';

            try {
                Mail::send(
                    'emails.generic',
                    $data,
                    function ($message) use ($subject, $distro, $i, $files) {
                        $message->subject($subject);
                        $message->from('no-reply@tpvhub.com');
                        $message->to(trim($distro[$i]));

                        // Add attachments
                        foreach ($files as $file) {
                            $message->attach($file);
                        }
                    }
                );
            } catch (\Exception $e) {
                $status .= 'Error! The reason reported is: ' . $e;
                $result->result = 'error';
                $result->messages[] = $status;
            }

            $status .= 'Success!';
            $result->messages[] = $status;
        }

        return $result;
    }

    /**
     * Writes a header-less CSV file from a data array.
     */
    private function writeCsvFile($data, $fileName) {

        try {
            $file = fopen($fileName, 'w');

            foreach($data as $line) {
                fputs($file, implode(',', $line) . "\r\n");
            }

            fclose($file);

        } catch (\Exception $e) {
            // TODO: Handle
        }

        // TODO: Return a result
    }
}
